{
  "datalog": "(relation edge (i64 i64))\n(relation path (i64 i64))\n\n(dl edge(1,2).)\n(dl edge(2,3).)\n(dl path(x,z) :- edge(x,y), path(y,z). )\n(dl path(x,y) :- edge(x,y). )\n\n(check (edge 1 2))\n(run 3)\n(check (path 1 3))\n(query ((path x y)))\n",
  "math-ast": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math))\n\n(define start (Add (Num 3) (Add (Num 4) (Var 42)))) ;; TODO typecheck this!\n(define goal  (Add (Num 7) (Var 42)))\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n\n(run 3)\n(check (= start goal))\n(extract start)\n",
  "interval": "(datatype Math\n  (Num rational)\n  (Var String)\n  (Mul Math Math))\n\n(function hi (Math) (Min rational))\n(function lo (Math) (Max rational))\n\n(rule ((= mul (Mul a b)))\n      ((= (lo mul) \n          (min (min (* (lo a) (lo b)) (* (lo a) (hi b)))\n               (min (* (hi a) (lo b)) (* (hi a) (hi b)))))))\n\n(define x (Var \"x\"))\n(define e (Mul x x))\n\n(assert (= (lo x) -10//1))\n(assert (= (hi x)  10//1))\n\n(run 1)\n\n(check (= (lo e) -100//1))\n\n(rule ((= mul (Mul a a)))\n      ((= (lo mul) (* (lo a) (lo a)))))\n\n(run 1)\n(check (= (lo e) 100//1))\n",
  "stratified": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n\n        \n(assert (edge 1 2))\n(assert (edge 2 3))\n(assert (edge 3 4))\n(check (edge 1 2))\n(run 3)\n(check (path 1 2))\n\n(clear-rules)\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(assert (edge 3 8))\n(run 1)\n(check (path 1 3))\n\n\n\n; Should fail\n; (check (path 1 4))\n; (check (path 3 8)) \n",
  "eqsolve": "(datatype Expr\n  (Add Expr Expr)\n  (Neg Expr)\n  (Num i64)\n  (Var String)\n)\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n(rule ((= (Add x y) z))\n      ((= (Add z (Neg y)) x)))\n(rewrite (Neg (Neg x)) x)\n(rewrite (Neg (Num n)) (Num (- 0 n)))\n;system 1: x + 2 = 7\n(assert (= (Add (Var \"x\") (Num 2)) (Num 7)))\n;system 2: z + y = 7, 2z = y\n(assert (= (Add (Var \"z\") (Var \"y\")) (Num 7)))\n(assert (= (Add (Var \"z\") (Var \"z\")) (Var \"y\")))\n\n(run 3)\n(extract (Var \"x\"))\n(extract (Var \"y\"))",
  "pathproof": "; proofs of connectivity are paths\n(datatype Proof\n  (Trans i64 Proof)\n  (Edge i64 i64))\n\n; We enhance the path relation to carry a proof field\n(relation path (i64 i64 Proof))\n(relation edge (i64 i64))\n\n(assert (edge 2 1))\n(assert (edge 3 2))\n(assert (edge 1 3))\n\n(rule ((edge x y))  \n      ((path x y (Edge x y))))\n(rule ((edge x y) (path y z p))  \n      ((path x z (Trans x p))))\n\n; We consider equal all paths tha connect same points.\n; Smallest Extraction will extract shortest path.\n(rule ((path x y p1) (path x y p2))  \n      ((= p1 p2)))\n\n(run 3)\n(check (path 3 1 (Trans 3 (Edge 2 1))))\n; Would prefer being able to check\n;(check (path 1 2 _))\n; or extract\n;(extract (path 1 4 ?p))",
  "unify": "(datatype Expr\n  (Mul Expr Expr)\n  (Var String)\n  (Lit i64)\n)\n\n; Assume injectivity of Mul for unification\n(rule ((= (Mul a b) (Mul c d)))\n   ((= a c) (= b d)))\n\n(relation False (i64))\n; If any Literal make equal to something it can't be, false is derived\n;(rule ((= (Lit i) (Lit j)) (!= i j))\n;      ((False 0)))\n(rule ((= (Lit i) (Mul a b)))\n      ((False 0)))\n\n(assert (= (Mul (Var \"a\") (Var \"a\")) \n           (Mul (Lit 1) (Lit 2))))\n\n\n(run 3)\n(check (= (Var \"a\") (Lit 1)))\n(check (= (Lit 2) (Lit 1)))\n; (check (False 0)) ;; this should fail because we don't want prove false",
  "primitives": "(check (= (+ 2 2)  4))\n(check (= (- 2 1)  1))\n(check (= (- 1 2) -1))",
  "path": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n        \n(assert (edge 1 2))\n(assert (edge 2 3))\n(assert (edge 3 4))\n(check (edge 1 2))\n(run 3)\n(check (path 1 4))"
}